package config

import (
	"fmt"
	"os"
	"strconv"
	"strings"
)

// Config represents the application configuration
type Config struct {
	Kubernetes KubernetesConfig `yaml:"kubernetes"`
	Git        GitConfig        `yaml:"git"`
	GitHub     GitHubConfig     `yaml:"github"`
	Checker    CheckerConfig    `yaml:"checker"`
}

// KubernetesConfig holds Kubernetes-related configuration
type KubernetesConfig struct {
	Namespace string `yaml:"namespace"`
}

// GitConfig holds Git-related configuration
type GitConfig struct {
	Repository string `yaml:"repository"`
	Token      string `yaml:"token"`
	Username   string `yaml:"username"`
	Email      string `yaml:"email"`
	Branch     string `yaml:"branch"`
}

// GitHubConfig holds GitHub-related configuration
type GitHubConfig struct {
	Token string `yaml:"token"`
	Owner string `yaml:"owner"`
	Repo  string `yaml:"repo"`
}

// CheckerConfig holds checker-related configuration
type CheckerConfig struct {
	DryRun           bool     `yaml:"dryRun"`
	ExcludeCharts    []string `yaml:"excludeCharts"`
	IncludeCharts    []string `yaml:"includeCharts"`
	CheckPrerelease  bool     `yaml:"checkPrerelease"`
	CommitMessage    string   `yaml:"commitMessage"`
	PullRequestTitle string   `yaml:"pullRequestTitle"`
	PullRequestBody  string   `yaml:"pullRequestBody"`
}

// Load loads configuration from environment variables
func Load() (*Config, error) {
	cfg := &Config{
		Kubernetes: KubernetesConfig{
			Namespace: getEnvOrDefault("KUBERNETES_NAMESPACE", ""),
		},
		Git: GitConfig{
			Repository: getEnvOrDefault("GIT_REPOSITORY", ""),
			Token:      getEnvOrDefault("GIT_TOKEN", ""),
			Username:   getEnvOrDefault("GIT_USERNAME", "helmchecker"),
			Email:      getEnvOrDefault("GIT_EMAIL", "helmchecker@example.com"),
			Branch:     getEnvOrDefault("GIT_BRANCH", "main"),
		},
		GitHub: GitHubConfig{
			Token: getEnvOrDefault("GITHUB_TOKEN", ""),
			Owner: getEnvOrDefault("GITHUB_OWNER", ""),
			Repo:  getEnvOrDefault("GITHUB_REPO", ""),
		},
		Checker: CheckerConfig{
			DryRun:           getBoolEnvOrDefault("CHECKER_DRY_RUN", false),
			CheckPrerelease:  getBoolEnvOrDefault("CHECKER_CHECK_PRERELEASE", false),
			CommitMessage:    getEnvOrDefault("CHECKER_COMMIT_MESSAGE", "chore: update helm chart %s to version %s"),
			PullRequestTitle: getEnvOrDefault("CHECKER_PR_TITLE", "Update Helm chart %s to version %s"),
			PullRequestBody:  getEnvOrDefault("CHECKER_PR_BODY", "This PR updates the Helm chart %s from version %s to %s.\n\n**Changes:**\n- Updated chart version\n- Updated application version (if applicable)\n\n**Testing:**\n- [ ] Chart linting passed\n- [ ] Deployment tested in staging\n\nGenerated by helmchecker ðŸ¤–"),
		},
	}

	// Validate configuration
	if err := cfg.Validate(); err != nil {
		return nil, err
	}

	return cfg, nil
}

// Validate validates the configuration
func (c *Config) Validate() error {
	var errors []string

	// Validate Git configuration
	if c.Git.Repository == "" {
		errors = append(errors, "GIT_REPOSITORY environment variable is required")
	}
	
	if c.Git.Token == "" && c.GitHub.Token == "" {
		errors = append(errors, "either GIT_TOKEN or GITHUB_TOKEN environment variable is required")
	}

	// If Git token is empty but GitHub token is set, use GitHub token for Git operations
	if c.Git.Token == "" && c.GitHub.Token != "" {
		c.Git.Token = c.GitHub.Token
	}

	// Validate GitHub configuration (required for creating PRs)
	if c.GitHub.Token == "" {
		errors = append(errors, "GITHUB_TOKEN environment variable is required")
	}
	
	if c.GitHub.Owner == "" {
		errors = append(errors, "GITHUB_OWNER environment variable is required")
	}
	
	if c.GitHub.Repo == "" {
		errors = append(errors, "GITHUB_REPO environment variable is required")
	}

	if len(errors) > 0 {
		return fmt.Errorf("configuration validation failed:\n  - %s", strings.Join(errors, "\n  - "))
	}

	return nil
}

func getEnvOrDefault(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func getBoolEnvOrDefault(key string, defaultValue bool) bool {
	if value := os.Getenv(key); value != "" {
		if parsed, err := strconv.ParseBool(value); err == nil {
			return parsed
		}
	}
	return defaultValue
}